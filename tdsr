#!/usr/bin/env python3
#tdsr, a terminal screen reader
#Copyright (C) 2016, 2017  Tyler Spivey
#See the license in COPYING.txt
import sys
import os
import select
import tty
import fcntl
import struct
import termios
import codecs
from io import StringIO
import subprocess
import time
import configparser
import re
import argparse
import shlex
import logging
import platform
import signal

import pyte

logger = logging.getLogger("tdsr")
logger.addHandler(logging.NullHandler())

TDSR_DIR = os.path.abspath(os.path.dirname(os.path.realpath(__file__)))
DEFAULT_CONFIG = os.path.join(TDSR_DIR, 'tdsr.cfg.dist')
CONFIG_FILE = os.path.expanduser('~/.tdsr.cfg')
CURSOR_TIMEOUT = 0.02
REPEAT_KEY_TIMEOUT = 0.5
PHONETICS = {x[0]: x for x in [
    'alpha', 'bravo', 'charlie', 'delta', 'echo', 'foxtrot',
    'golf', 'hotel', 'india', 'juliet', 'kilo', 'lima', 'mike',
    'november', 'oscar', 'papa', 'quebec', 'romeo', 'sierra',
    'tango', 'uniform', 'victor', 'wiskey', 'x ray', 'yankee',
    'zulu']}

class State:
    def __init__(self):
        '''
        __init__
        '''
        self.revy = 0
        self.revx = 0
        self.delayed_functions = []
        self.silence = False
        self.tempsilence = False
        self.key_handlers = []
        self.config = configparser.ConfigParser()
        self.config['speech'] = {
            'process_symbols': 'false',
            'key_echo': True,
            'cursor_tracking': True,
        }
        self.config['symbols'] = {}
        self.symbols_re = None
        self.copy_x = None
        self.copy_y = None
        self.last_drawn_x = 0
        self.last_drawn_y = 0
        self.delaying_output = False

    def save_config(self):
        '''
        save_config
        '''
        with open(CONFIG_FILE, 'w') as file_p:
            self.config.write(file_p)

    def build_symbols_re(self):
        '''
        build_symbols_re
        '''
        candidates = []
        for symbol in self.config['symbols']:
            symbol = int(symbol)
            if symbol == 32:
                continue
            candidates.append(re.escape(chr(symbol)))
        if not candidates:
            return None
        return re.compile('|'.join(candidates))

class KeyHandler:
    PASSTHROUGH = 1
    REMOVE = 2
    def __init__(self, keymap, file_descriptor=None):
        '''
        __init__
        '''
        self.keymap = keymap
        self.file_descriptor = file_descriptor
        self.last_key = None
        self.last_key_time = 0.0

    def process(self, data):
        '''
        process
        '''
        key_time = time.time()
        key_delta = key_time - self.last_key_time
        self.last_key_time = key_time
        repeat = data + data
        if data not in self.keymap:
            self.last_key = data
            return self.handle_unknown_key(data)
        elif self.last_key == data and repeat in self.keymap and key_delta <= REPEAT_KEY_TIMEOUT:
            result = self.keymap[repeat]()
            self.last_key = data
            return result
        else:
            result = self.keymap[data]()
            if result == KeyHandler.PASSTHROUGH:
                os.write(self.file_descriptor, data)
            self.last_key = data
            return result

    def handle_unknown_key(self, data):
        '''
        handle_unknown_key
        '''
        os.write(self.file_descriptor, data)

class ConfigHandler(KeyHandler):
    def __init__(self):
        '''
        __init__
        '''
        self.keymap = {
            b'r': self.set_rate,
            b'v': self.set_volume,
            b'p': self.set_process_symbols,
            b'd': self.set_delay,
            b'e': self.set_echo,
            b'c': self.set_cursor_tracking,
        }
        super().__init__(self.keymap)

    def set_rate(self):
        '''
        set_rate
        '''
        say("Rate")
        state.key_handlers.append(BufferHandler(on_accept=self.set_rate2))

    def set_rate2(self, val):
        '''
        set_rate2
        '''
        try:
            val = int(val)
        except ValueError:
            say("Invalid value")
            return
        synth.set_rate(val)
        state.config['speech']['rate'] = str(val)
        state.save_config()
        say("Confirmed")

    def set_volume(self):
        '''
        set_volume
        '''
        say("volume")
        state.key_handlers.append(BufferHandler(on_accept=self.set_volume2))

    def set_volume2(self, val):
        '''
        set_volume2
        '''
        try:
            val = int(val)
        except ValueError:
            say("Invalid value")
            return
        synth.set_volume(val)
        state.config['speech']['volume'] = str(val)
        state.save_config()
        say("Confirmed")

    def set_process_symbols(self):
        '''
        set_process_symbols
        '''
        current = state.config.getboolean('speech', 'process_symbols', fallback=False)
        current = not current
        state.config['speech']['process_symbols'] = str(current)
        state.save_config()
        say("process symbols on" if current else "process symbols off")

    def set_echo(self):
        '''
        set_echo
        '''
        current = state.config.getboolean('speech', 'key_echo', fallback=True)
        current = not current
        state.config['speech']['key_echo'] = str(current)
        state.save_config()
        say("character echo on" if current else "character echo off")

    def set_cursor_tracking(self):
        '''
        set_cursor_tracking
        '''
        current = state.config.getboolean('speech', 'cursor_tracking', fallback=True)
        current = not current
        state.config['speech']['cursor_tracking'] = str(current)
        state.save_config()
        say("cursor tracking on" if current else "cursor tracking off")

    def set_delay(self):
        '''
        set_delay
        '''
        say("Cursor delay")
        state.key_handlers.append(BufferHandler(on_accept=self.set_delay2))

    def set_delay2(self, val):
        '''
        set_delay2
        '''
        global CURSOR_TIMEOUT
        try:
            val = int(val)
        except ValueError:
            say("Invalid value")
            return
        val /= 1000
        CURSOR_TIMEOUT = val
        state.config['speech']['cursor_delay'] = str(val)
        state.save_config()
        say("Confirmed")

    def handle_unknown_key(self, data):
        '''
        handle_unknown_key
        '''
        if data == b'\r' or data == b'\n':
            say("exit")
            return KeyHandler.REMOVE

class CopyHandler(KeyHandler):
    def __init__(self):
        '''
        __init__
        '''
        keymap = {
            b'l': self.copy_line,
            b's': self.copy_screen,
        }
        super().__init__(keymap)

    def copy_line(self):
        '''
        copy_line
        '''
        try:
            copy_text(state.revy, 0, state.revy, screen.columns-1)
        except:
            say("Failed")
        else:
            say("line")
        return KeyHandler.REMOVE

    def copy_screen(self):
        '''
        copy_screen
        '''
        try:
            copy_text(0, 0, screen.lines - 1, screen.columns - 1)
        except:
            say("Failed")
        else:
            say("screen")
        return KeyHandler.REMOVE

    def handle_unknown_key(self, data):
        '''
        handle_unknown_key
        '''
        say("unknown key")
        return KeyHandler.REMOVE

class BufferHandler(KeyHandler):
    def __init__(self, on_accept=None):
        '''
        __init__
        '''
        self.on_accept = on_accept
        self.buffer = ''
        super().__init__(keymap={})

    def process(self, data):
        '''
        process
        '''
        if data == b'\r' or data == b'\n':
            self.on_accept(self.buffer)
            return KeyHandler.REMOVE
        else:
            self.buffer += data.decode('utf-8')

class Synth:
    def __init__(self, speech_server):
        '''
        __init__
        '''
        self.pipe = None
        self.speech_server = speech_server
        self.rate = None
        self.volume = None

    def start(self):
        '''
        start
        '''
        self.pipe = subprocess.Popen(self.speech_server, stdin=subprocess.PIPE)
        if self.rate:
            self.set_rate(self.rate)
        if self.volume:
            self.set_volume(self.volume)

    def send(self, text):
        '''
        send
        '''
        text = text.encode('utf-8')
        try:
            self.pipe.stdin.write(text)
            self.pipe.stdin.flush()
        except BrokenPipeError:
            try:
                self.start()
                self.pipe.stdin.write(text)
                self.pipe.stdin.flush()
            except BrokenPipeError:
                pass # We'll try to restart next time something is sent

    def set_rate(self, rate):
        '''
        set_rate
        '''
        self.rate = rate
        self.send('r%d\n' % rate)

    def set_volume(self, volume):
        '''
        set_volume
        '''
        self.volume = volume
        self.send('v%d\n' % volume)

    def close(self):
        '''
        close
        '''
        self.pipe.stdin.close()
        self.pipe.wait()

state = State()
speech_buffer = StringIO()
lastkey = ""
def main():
    '''
    main
    '''
    global CURSOR_TIMEOUT, signal_pipe
    parser = argparse.ArgumentParser()
    parser.add_argument('-s',
                        '--speech-server',
                        action='store',
                        help='speech server command to run')
    parser.add_argument('--debug', action='store_true')
    parser.add_argument('program', action='store', nargs='*')
    args = parser.parse_args()
    if args.speech_server is None:
        if platform.system() == 'Darwin':
            speech_server = os.path.join(TDSR_DIR, 'mac')
        else:
            # Works on Linux, hopefully other places too:
            speech_server = os.path.join(TDSR_DIR, 'speechdispatcher')
    else:
        speech_server = shlex.split(args.speech_server)
    if args.debug:
        logger.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        f_handler = logging.FileHandler('tdsr.log')
        f_handler.setFormatter(formatter)
        logger.addHandler(fh)
        logger.debug("TDSR started")
    rows, cols = get_terminal_size(0)
    global synth, screen
    synth = Synth(speech_server)
    synth.start()
    if os.path.exists(DEFAULT_CONFIG) and not os.path.exists(CONFIG_FILE):
        state.config.read(DEFAULT_CONFIG)
        state.save_config()
    state.config.read(CONFIG_FILE)
    state.symbols_re = state.build_symbols_re()
    if 'rate' in state.config['speech']:
        synth.set_rate(int(state.config['speech']['rate']))
    if 'volume' in state.config['speech']:
        synth.set_volume(int(state.config['speech']['volume']))
    if 'cursor_delay' in state.config['speech']:
        CURSOR_TIMEOUT = float(state.config['speech']['cursor_delay'])
    pid, file_descriptor = os.forkpty()
    if pid == 0:
        handle_child(args)
    screen = MyScreen(cols, rows)
    stream = pyte.Stream()
    stream.attach(screen)
    screen.define_charset('B', '(')
    decoder = codecs.getincrementaldecoder('utf-8')(errors='replace')
    default_key_handler = KeyHandler(keymap, file_descriptor)
    state.key_handlers.append(default_key_handler)
    termios.tcsetattr(file_descriptor, termios.TCSADRAIN, old)
    resize_terminal(file_descriptor)
    signal_pipe = os.pipe()
    signal.signal(signal.SIGWINCH, handle_sigwinch)
    say("tdsr, presented by Lighthouse of San Francisco")
    while True:
        rlist, wlist, xlist = select.select(
            [sys.stdin, file_descriptor, signal_pipe[0]],
            [],
            [],
            time_until_next_delayed())
        if signal_pipe[0] in rlist:
            os.read(signal_pipe[0], 1)
            old_x, old_y = screen.cursor.x, screen.cursor.y
            rows, cols = resize_terminal(file_descriptor)
            screen.resize(rows, cols)
            state.revx = min(state.revx, cols - 1)
            state.revy = min(state.revy, rows - 1)
            screen.cursor.x = min(old_x, cols - 1)
            screen.cursor.y = min(old_y, rows - 1)
        if sys.stdin in rlist:
            bytes = os.read(0, 4096)
            process_input(bytes, file_descriptor)
        if file_descriptor in rlist:
            try:
                bytes = read_all(file_descriptor)
            except (EOFError, OSError):
                speech_buffer()
                synth.close()
                sys.exit(0)
            decoded_bytes = decoder.decode(bytes)
            old_x, old_y = screen.cursor.x, screen.cursor.y
            stream.feed(decoded_bytes)
            if state.config.getboolean('speech', 'cursor_tracking') and (
                    screen.cursor.x != old_x or screen.cursor.y != old_y):
                state.revx, state.revy = screen.cursor.x, screen.cursor.y
            if not state.silence and not state.tempsilence:
                if speech_buffer.tell() > 0 and not state.delaying_output:
                    schedule(0.001, read_buffer_scheduled)
            os.write(1, bytes)
        run_scheduled()

def read_buffer_scheduled():
    '''
    read_buffer_scheduled
    '''
    state.delaying_output = False
    speech_buffer()

def read_all(file_descriptor):
    '''
    read_all
    '''
    bytes = os.read(file_descriptor, 4096)
    if bytes == b'':
        raise EOFError
    while has_more(file_descriptor):
        data = os.read(file_descriptor, 4096)
        if data == b'':
            raise EOFError
        bytes += data
    return bytes

def handle_child(args):
    '''
    handle_child
    '''
    if args.program:
        program = shlex.split(" ".join(args.program))
    else:
        program = [os.environ["SHELL"]]
    os.execv(program[0], program)

newbytes = StringIO()
in_escape = False
escsec = ""
def process_input(bytes, file_descriptor):
    '''
    process_input
    '''
    global lastkey
    lastkey = ""
    silence()
    state.delayed_functions = []
    state.tempsilence = False
    res = state.key_handlers[-1].process(bytes)
    if res == KeyHandler.REMOVE:
        state.key_handlers = state.key_handlers[:-1]
    lastkey = bytes.decode('utf-8', 'replace')

def handle_backspace():
    '''
    handle_backspace
    '''
    cur_x = screen.cursor.x
    if cur_x > 0:
        say_character(screen.display[screen.cursor.y][screen.cursor.x - 1])
    return KeyHandler.PASSTHROUGH

def handle_delete():
    '''
    handle_delete
    '''
    cur_x = screen.cursor.x
    say_character(screen.display[screen.cursor.y][screen.cursor.x])
    return KeyHandler.PASSTHROUGH

def sayline(line_num):
    '''
    sayline
    '''
    line = screen.display[line_num].strip()
    if line == u'':
        line = u'blank'
    say(line)

def prevline():
    '''
    prevline
    '''
    state.revy -= 1
    if state.revy < 0:
        say("top")
        state.revy = 0
    sayline(state.revy)

def nextline():
    '''
    nextline
    '''
    state.revy += 1
    if state.revy > screen.lines - 1:
        say("bottom")
        state.revy = screen.lines - 1
    sayline(state.revy)

def prevchar():
    '''
    prevchar
    '''
    state.revx -= 1
    if state.revx < 0:
        say("left")
        state.revx = 0
    saychar(state.revy, state.revx)

def saychar(at_y, at_x, phonetically=False):
    '''
    saychar
    '''
    char = screen.display[at_y][at_x]
    lchar = char.lower()
    if phonetically and lchar in PHONETICS:
        synth.send('s%s\n' % PHONETICS[lchar])
    else:
        say_character(char)

def nextchar():
    '''
    nextchar
    '''
    state.revx += 1
    if state.revx > screen.columns - 1:
        say("right")
        state.revx = screen.columns - 1
    saychar(state.revy, state.revx)

def top_of_screen():
    '''
    top_of_screen
    '''
    state.revy = 0
    sayline(state.revy)

def bottom_of_screen():
    '''
    bottom_of_screen
    '''
    state.revy = screen.lines - 1
    sayline(state.revy)

def start_of_line():
    '''
    start_of_line
    '''
    state.revx = 0
    saychar(state.revy, state.revx)

def end_of_line():
    '''
    end_of_line
    '''
    state.revx = screen.columns - 1
    saychar(state.revy, state.revx)

class MyScreen(pyte.Screen):

    def set_margins(self, top=None, bottom=None):
        '''
        set_margins
        '''
        if top == 0 and bottom is None:
            top = None
        super().set_margins(top=top, bottom=bottom)

    def draw(self, text):
        '''
        draw
        '''
        for char in text:
            self.draw2(char)

    def draw2(self, text):
        '''
        draw2
        '''
        global lastkey
        logger.debug("Drawing %r", text)
        add_to_buffer = True
        if text == lastkey:
            add_to_buffer = False
            if len(text) == 1 and state.config.getboolean('speech', 'key_echo', fallback=False):
                say_character(text)
        lastkey = ""
        if screen.cursor.y == state.last_drawn_y and screen.cursor.x - state.last_drawn_x > 1:
            speech_buffer.write(' ')
        super(MyScreen, self).draw(text)
        if add_to_buffer and not state.silence and not state.tempsilence:
            speech_buffer.write(text)
            state.last_drawn_x = screen.cursor.x
            state.last_drawn_y = screen.cursor.y

    def tab(self):
        '''
        tab
        '''
        if not state.silence:
            speech_buffer.write(' ')
        super().tab()

    def linefeed(self):
        '''
        linefeed
        '''
        speech_buffer()
        super(MyScreen, self).linefeed()

    def backspace(self):
        '''
        backspace
        '''
        if self.cursor.x > 0 and speech_buffer.tell() > 0:
            speech_buffer.seek(speech_buffer.tell() - 1)
        super(MyScreen, self).backspace()

    def reset_mode(self, *modes, **kwargs):
        '''
        reset_mode
        '''
        if 3 in modes:
            modes = list(modes)
            modes.remove(3)
        super().reset_mode(*modes, **kwargs)

    def set_mode(self, *modes, **kwargs):
        '''
        set_mode
        '''
        if 3 in modes:
            modes = list(modes)
            modes.remove(3)
        super().set_mode(*modes, **kwargs)

    def erase_in_display(self, how=0, private=False):
        '''
        erase_in_display
        '''
        if how == 3:
            return
        super().erase_in_display(how, private=private)

def speech_buffer():
    '''
    speech_buffer
    '''
    data = speech_buffer.getvalue()
    speech_buffer.truncate(0)
    speech_buffer.seek(0)
    if data == u'':
        return
    if not state.tempsilence:
        say(data)

def say(data, force_process_symbols=False):
    '''
    say
    '''
    data = data.strip()
    def replace_symbols(msg):
        '''
        replace_symbols
        '''
        return " %s " % state.config['symbols'][str(ord(msg.group(0)))]
    if state.symbols_re is not None and \
            (force_process_symbols or \
            state.config.getboolean('speech', 'process_symbols', fallback=False)):
        data = state.symbols_re.sub(replace_symbols, data)
    synth.send("s" + data + "\n")

def silence():
    '''
    silence
    '''
    synth.send('x\n')

def say_character(char):
    '''
    say_character
    '''
    key = str(ord(char))
    if key in state.config['symbols']:
        synth.send('s%s\n' % state.config['symbols'][key])
    else:
        synth.send('l%s\n' % char)

def arrow_up():
    '''
    arrow_up
    '''
    schedule(CURSOR_TIMEOUT, (lambda: sayline(screen.cursor.y)), True)
    return KeyHandler.PASSTHROUGH

def arrow_down():
    '''
    arrow_down
    '''
    schedule(CURSOR_TIMEOUT, (lambda: sayline(screen.cursor.y)), True)
    return KeyHandler.PASSTHROUGH

def arrow_left():
    '''
    arrow_left
    '''
    schedule(CURSOR_TIMEOUT, (lambda: saychar(screen.cursor.y, screen.cursor.x)), True)
    return KeyHandler.PASSTHROUGH

def arrow_right():
    '''
    arrow_right
    '''
    schedule(CURSOR_TIMEOUT, (lambda: saychar(screen.cursor.y, screen.cursor.x)), True)
    return KeyHandler.PASSTHROUGH

def schedule(timeout, func, set_tempsilence=False):
    '''
    schedule
    '''
    state.delayed_functions.append((time.time() + timeout, func))
    if set_tempsilence:
        state.tempsilence = True

def run_scheduled():
    '''
    run_scheduled
    '''
    if not state.delayed_functions:
        return
    to_remove = []
    curtime = time.time()
    for item in state.delayed_functions:
        time, func = item
        if curtime >= time:
            func()
            to_remove.append(item)
    for item in to_remove:
        state.delayed_functions.remove(item)

def time_until_next_delayed():
    '''
    time_until_next_delayed
    '''
    if not state.delayed_functions:
        return None
    return max(0, state.delayed_functions[0][0] - time.time())

def config():
    '''
    config
    '''
    say("config")
    state.key_handlers.append(ConfigHandler())

def copy_mode():
    '''
    copy_mode
    '''
    say("copy")
    state.key_handlers.append(CopyHandler())

def get_char(disp=None):
    '''
    get_char
    '''
    if disp is None:
        disp = screen.disp
    return disp[state.revy][state.revx]

def move_prevchar():
    '''
    move_prevchar
    '''
    if state.revx == 0:
        if state.revy == 0:
            return ''
        state.revy -= 1
        state.revx = screen.columns - 1
    else:
        state.revx -= 1

def move_nextchar():
    '''
    move_nextchar
    '''
    if state.revx == screen.columns - 1:
        if state.revy == screen.lines - 1:
            return ''
        state.revy += 1
        state.revx = 0
    else:
        state.revx += 1

def prevword():
    '''
    prevword
    '''
    if state.revx == 0:
        say("left")
        sayword()
        return
    disp = screen.display
    #Move over any existing word we might be in the middle of
    while state.revx > 0 and get_char(disp) != ' ':
        move_prevchar()
    #Skip whitespace
    while state.revx > 0 and get_char(disp) == ' ':
        move_prevchar()
    #Move to the beginning of the word we're now on
    while state.revx > 0 and get_char(disp) != ' ' and \
            screen.display[state.revy][state.revx - 1] != ' ':
        move_prevchar()
    sayword()

def sayword(spell=False):
    '''
    sayword
    '''
    word = ""
    revx, revy = state.revx, state.revy
    disp = screen.display
    while state.revx > 0 and get_char(disp) != ' ' and d[state.revy][state.revx - 1] != ' ':
        move_prevchar()
    if state.revx == 0 and get_char(disp) == ' ':
        say("space")
        return
    while state.revx < screen.columns - 1:
        word += get_char(disp)
        move_nextchar()
        if get_char(disp) == ' ':
            break
    if spell:
        say(' '.join(word), force_process_symbols=True)
    else:
        say(word)
    state.revx, state.revy = revx, revy

def nextword():
    '''
    nextword
    '''
    revx, revy = state.revx, state.revy
    move = screen.columns - 1
    disp = screen.display
    #Move over any existing word we might be in the middle of
    while state.revx < move and get_char(disp) != ' ':
        move_nextchar()
    #Skip whitespace
    while state.revx < move and get_char(d) == ' ':
        move_nextchar()
    if state.revx == move and get_char(d) == ' ':
        say("right")
        state.revx = revx
        sayword()
        return
    sayword()

def handle_silence():
    '''
    handle_silence
    '''
    state.silence = not state.silence
    say("quiet on" if state.silence else "quiet off")

def handle_clipboard():
    '''
    handle_clipboard
    '''
    if state.copy_x is None:
        state.copy_x = state.revx
        state.copy_y = state.revy
        say("select")
        return
    end_x, end_y = state.revx, state.revy
    try:
        copy_text(state.copy_y, state.copy_x, end_y, end_x)
    except:
        say("Failed")
    else:
        say("copied")
    state.copy_x = None

def copy_text(start_y, start_x, end_y, end_x):
    '''
    copy_text
    '''
    if start_x > end_x:
        start_x, end_x = end_x, start_x
    if start_y > end_y:
        start_y, end_y = end_y, start_y
    lines = (end_y - start_y) + 1
    cols = (end_x - start_x) + 1
    display = screen.display
    buf = []
    start = start_x
    for y_pos in range(lines):
        if lines > 1 and y_pos < lines - 1:
            end = screen.columns - 1
        else:
            end = end_x
        if y > 0:
            start = 0
        data = display[start_y+y][start:end + 1].rstrip()
        buf.append(data)
    buf = "\n".join(buf)
    copy_to_clip(buf)

def copy_to_clip(data):
    '''
    copy_to_clip
    '''
    data = data.encode('utf-8')
    if platform.system() == 'Darwin':
        proc = subprocess.Popen('pbcopy', stdin=subprocess.PIPE)
        proc.stdin.write(data)
        proc.stdin.close()
    elif platform.system() == 'Linux':
        proc = subprocess.Popen(['xclip', '-selection', 'clip'], stdin=subprocess.PIPE)
        proc.stdin.write(data)
        proc.stdin.close()

def has_more(file_descriptor):
    '''
    has_more
    '''
    rlist, wlist, elist = select.select([file_descriptor], [], [], 0)
    if file_descriptor in rlist:
        return True
    return False

def get_terminal_size(file_descriptor):
    '''
    get_terminal_size
    '''
    struc = struct.pack('HHHH', 0, 0, 0, 0)
    rows, cols, _, _ = struct.unpack(
        'HHHH',
        fcntl.ioctl(file_descriptor, termios.TIOCGWINSZ, struc))
    return rows, cols

def resize_terminal(file_descriptor):
    '''
    resize_terminal
    '''
    struc = struct.pack('HHHH', 0, 0, 0, 0)
    struc = fcntl.ioctl(0, termios.TIOCGWINSZ, struc)
    fcntl.ioctl(file_descriptor, termios.TIOCSWINSZ, struc)
    rows, cols, _, _ = struct.unpack('hhhh', struc)
    return rows, cols

def handle_sigwinch(*args):
    '''
    handle_sigwinch
    '''
    os.write(signal_pipe[1], b'w')

keymap = {
    b'\x1bi': lambda: sayline(state.revy),
    b'\x1bu': prevline,
    b'\x1bo': nextline,
    b'\x1bj': prevword,
    b'\x1bk': sayword,
    b'\x1bk\x1bk': lambda: sayword(spell=True),
    b'\x1bl': nextword,
    b'\x1bm': prevchar,
    b'\x1b,': lambda: saychar(state.revy, state.revx),
    b'\x1b,\x1b,': lambda: saychar(state.revy, state.revx, phonetically=True),
    b'\x1b.': nextchar,
    b'\x1bU': top_of_screen,
    b'\x1bO': bottom_of_screen,
    b'\x1bM': start_of_line,
    b'\x1b>': end_of_line,
    # For the Hungarian keyboard layout
    b'\x1b:': end_of_line,
    b'\x1bc': config,
    b'\x1bq': handle_silence,
    b'\x1br': handle_clipboard,
    b'\x1bv': copy_mode,
    b'\x1bx': silence,
    b'\x08': handle_backspace,
    b'\x7f': handle_backspace,
    b'\x1b[3~': handle_delete,
    b'\x1b[A': arrow_up,
    b'\x1b[B': arrow_down,
    b'\x1b[C': arrow_right,
    b'\x1b[D': arrow_left,
    #
    b'\x1bOA': arrow_up,
    b'\x1bOB': arrow_down,
    b'\x1bOC': arrow_right,
    b'\x1bOD': arrow_left,
}

if __name__ == '__main__':
    try:
        old = termios.tcgetattr(0)
        tty.setraw(0)
        main()
    finally:
        termios.tcsetattr(0, termios.TCSADRAIN, old)
